# 实现定义

包含具体的实现的细节的定义

## 换段字符

换行使用 `\n` 字符

使用单个字符可以在各个光标逻辑里面，不需要额外考虑换段字符是两个字符。比如按下退格键删除时，如果采用 `\r\n` 作为换段字符，那就需要判断当前是否在某段末尾，如果是就需要使用加二计算，相对来说比较麻烦。如果只采用一个 `\n` 字符，那就方便许多了，依然只需要执行减一即可

## 空文本

### 空文本段落数量

对外，一个空文本至少存在一段一行

内部，在没有获取时，是不会创建一段一行的，只有在获取段落之后，才会创建首个空段。在布局之后才创建首个空行

这只是为了做性能优化，才不会默认创建一段一行。对外可以获取到一段一行可以减少上层业务的判断逻辑

## 文档系统

### 删除超过文本字符范围

例如文本包含字符串 "12" 两个字符，从光标坐标 1 开始，删除三个字符，无疑是超过文档范围的。这时有两个选择

1. 删除到不能删，就停下
2. 抛出异常，不给删除

决定抛出异常，因为对于 `string.Substring` 来说，将会在超过范围抛出 `System.ArgumentOutOfRangeException:“Index and length must refer to a location within the string. Arg_ParamName_Name”` 异常，例如执行以下代码

```csharp
            var substring = "12".Substring(1,3);
```

文本库的删除类似于字符串的行为，决定行为保持和 string 类型相同

## 渲染

### 渲染行缓存

渲染的时候，如果一行没有被更改，意味着这一行的渲染内容可以复用。在文本库里，通过 ParagraphLineRenderInfo 参数设置行渲染信息，也就是以下方法

```csharp
ParagraphLineRenderInfo.SetDrawnResult(in LineDrawnResult lineDrawnResult)
```

设置进入的 LineDrawnResult 是一个 object 类型。将会在下次渲染时，带入到 LineDrawingArgument 参数里面

加上行渲染缓存，可以比较大提升重复渲染的性能

## 遇到的问题

对于文本字符来说，文本字符属性是采用不可变对象，尽量使用相同的对象。但是这样就存在一个问题，那就是超链接。超链接点击的时候需要修改超链接的颜色。如果超链接的文本字符属性被分割开，那是否影响被分割的内容？其实不然。这里就存在破坏设计

输入的文本需要判断是否可以使用前后继承的文本字符属性，从而减少文本字符属性的数量

## 光标系统

### 光标和选择的绘制

光标的闪烁是一个比较大的坑，当前 WPF 的 TextBox 依然存在一些情况下，丢失闪烁的光标。另外团队之前的文本库存在了光标不闪烁或者是选择和光标同存的问题

在此文本库通过设计的手段规避，代码放在 SelectionAndCaretLayer 层里面。光标的显示与否绑定了 IsInEditingInputMode 属性，且尽可能开启计时器进行光标闪烁判断逻辑。不设置独立的光标显示或隐藏控制，而是通过监听文本统一事件决定是否显示或隐藏

让光标和选择范围显示放在相同的一个 DrawingVisual 里面，如此可确保相同时刻只有光标或选择范围一个显示，彻底解决选择和光标同存的问题